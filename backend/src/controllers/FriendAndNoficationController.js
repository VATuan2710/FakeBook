import FriendRequest from "../models/FriendRequest.js";
import Notification from "../models/Notification.js";
import User from "../models/User.js";

// Get socket.io instance from server
let io;
export const setSocketIO = (socketInstance) => {
  io = socketInstance;
};

// üìå G·ª≠i l·ªùi m·ªùi k·∫øt b·∫°n
export const sendFriendRequest = async (req, res) => {
  try {
    const { sender, receiver } = req.body;

    if (sender === receiver) {
      return res
        .status(400)
        .json({ message: "Kh√¥ng th·ªÉ t·ª± k·∫øt b·∫°n v·ªõi ch√≠nh m√¨nh!" });
    }

    // Ki·ªÉm tra xem ƒë√£ l√† b·∫°n b√® ch∆∞a
    const senderUser = await User.findById(sender);
    if (senderUser.friends.includes(receiver)) {
      return res.status(400).json({ message: "ƒê√£ l√† b·∫°n b√® r·ªìi!" });
    }

    // Ki·ªÉm tra xem ƒë√£ g·ª≠i l·ªùi m·ªùi ch∆∞a
    const existingRequest = await FriendRequest.findOne({
      sender,
      receiver,
      status: "pending",
    });
    if (existingRequest) {
      return res.status(400).json({ message: "B·∫°n ƒë√£ g·ª≠i l·ªùi m·ªùi tr∆∞·ªõc ƒë√≥!" });
    }

    // Ki·ªÉm tra xem c√≥ l·ªùi m·ªùi ng∆∞·ª£c l·∫°i kh√¥ng
    const reverseRequest = await FriendRequest.findOne({
      sender: receiver,
      receiver: sender,
      status: "pending",
    });
    if (reverseRequest) {
      return res.status(400).json({ message: "Ng∆∞·ªùi n√†y ƒë√£ g·ª≠i l·ªùi m·ªùi cho b·∫°n!" });
    }

    // T·∫°o l·ªùi m·ªùi m·ªõi
    const friendRequest = new FriendRequest({ sender, receiver });
    await friendRequest.save();

    // Populate sender info for response
    await friendRequest.populate('sender receiver', 'username firstName lastName avatarUrl displayName');

    // üìå T·∫°o th√¥ng b√°o k·∫øt b·∫°n
    const notification = new Notification({
      user: receiver,
      sender: sender,
      type: "friend_request",
      message: "B·∫°n c√≥ m·ªôt l·ªùi m·ªùi k·∫øt b·∫°n m·ªõi!",
    });
    await notification.save();
    await notification.populate('sender', 'username firstName lastName avatarUrl displayName');

    // üîî EMIT SOCKET EVENT - Real-time notification
    if (io) {
      io.emit("send_friend_request", {
        fromUser: sender,
        toUser: receiver,
        requestId: friendRequest._id,
        fromUserData: {
          _id: friendRequest.sender._id,
          displayName: friendRequest.sender.displayName || `${friendRequest.sender.firstName} ${friendRequest.sender.lastName}`,
          username: friendRequest.sender.username,
          avatarUrl: friendRequest.sender.avatarUrl
        }
      });

      console.log(`üîî Socket: Friend request sent from ${sender} to ${receiver}`);
    }

    res.status(201).json({ 
      message: "L·ªùi m·ªùi k·∫øt b·∫°n ƒë√£ ƒë∆∞·ª£c g·ª≠i!",
      friendRequest: friendRequest,
      notification: notification
    });
  } catch (error) {
    console.error("L·ªói khi g·ª≠i l·ªùi m·ªùi k·∫øt b·∫°n:", error);
    res.status(500).json({ message: "L·ªói server!" });
  }
};

// üìå Ch·∫•p nh·∫≠n l·ªùi m·ªùi k·∫øt b·∫°n
export const acceptFriendRequest = async (req, res) => {
  try {
    const { requestId } = req.params;

    const friendRequest = await FriendRequest.findById(requestId)
      .populate('sender receiver', 'username firstName lastName avatarUrl displayName');
    
    if (!friendRequest) {
      return res
        .status(404)
        .json({ message: "Kh√¥ng t√¨m th·∫•y l·ªùi m·ªùi k·∫øt b·∫°n!" });
    }

    const { sender, receiver } = friendRequest;

    // C·∫≠p nh·∫≠t danh s√°ch b·∫°n b√®
    await User.findByIdAndUpdate(sender._id, { $addToSet: { friends: receiver._id } });
    await User.findByIdAndUpdate(receiver._id, { $addToSet: { friends: sender._id } });

    // X√≥a l·ªùi m·ªùi sau khi ƒë√£ ch·∫•p nh·∫≠n
    await FriendRequest.findByIdAndDelete(requestId);

    // üìå T·∫°o th√¥ng b√°o b·∫°n b√®
    const notification = new Notification({
      user: sender._id,
      sender: receiver._id,
      type: "friend_accept",
      message: "L·ªùi m·ªùi k·∫øt b·∫°n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c ch·∫•p nh·∫≠n!",
    });
    await notification.save();

    // üîî EMIT SOCKET EVENT - Real-time notification
    if (io) {
      io.emit("friend_request_accepted", {
        fromUser: sender._id,
        toUser: receiver._id,
        toUserData: {
          _id: receiver._id,
          displayName: receiver.displayName || `${receiver.firstName} ${receiver.lastName}`,
          username: receiver.username,
          avatarUrl: receiver.avatarUrl
        }
      });

      console.log(`üîî Socket: Friend request accepted ${receiver._id} ‚Üí ${sender._id}`);
    }

    res.status(200).json({ 
      message: "B·∫°n ƒë√£ k·∫øt b·∫°n th√†nh c√¥ng!",
      newFriend: {
        _id: sender._id,
        displayName: sender.displayName,
        username: sender.username,
        avatarUrl: sender.avatarUrl
      }
    });
  } catch (error) {
    console.error("L·ªói khi ch·∫•p nh·∫≠n l·ªùi m·ªùi:", error);
    res.status(500).json({ message: "L·ªói server!" });
  }
};

// h·ªßy l·ªùi m·ªùi k·∫øt b·∫°n
export const cancelFriendRequest = async (req, res) => {
  try {
    const { sender, receiver } = req.body;

    const friendRequest = await FriendRequest.findOneAndDelete({
      sender,
      receiver,
      status: "pending",
    });

    if (!friendRequest) {
      return res
        .status(404)
        .json({ message: "Kh√¥ng t√¨m th·∫•y l·ªùi m·ªùi k·∫øt b·∫°n!" });
    }

    res.status(200).json({ message: "L·ªùi m·ªùi k·∫øt b·∫°n ƒë√£ b·ªã h·ªßy!" });
  } catch (error) {
    console.error("L·ªói khi h·ªßy l·ªùi m·ªùi k·∫øt b·∫°n:", error);
    res.status(500).json({ message: "L·ªói server!" });
  }
};

// t·ª´ ch·ªëi k·∫øt b·∫°n
export const declineFriendRequest = async (req, res) => {
  try {
    const { requestId } = req.params;

    const friendRequest = await FriendRequest.findById(requestId)
      .populate('sender receiver', 'username firstName lastName avatarUrl displayName');

    if (!friendRequest) {
      return res
        .status(404)
        .json({ message: "Kh√¥ng t√¨m th·∫•y l·ªùi m·ªùi k·∫øt b·∫°n!" });
    }

    const { sender, receiver } = friendRequest;
    
    // X√≥a l·ªùi m·ªùi
    await FriendRequest.findByIdAndDelete(requestId);

    // üîî EMIT SOCKET EVENT - Real-time notification (optional)
    if (io) {
      io.emit("friend_request_declined", {
        fromUser: sender._id,
        toUser: receiver._id,
        toUserData: {
          _id: receiver._id,
          displayName: receiver.displayName || `${receiver.firstName} ${receiver.lastName}`,
          username: receiver.username,
          avatarUrl: receiver.avatarUrl
        }
      });

      console.log(`üîî Socket: Friend request declined ${receiver._id} ‚Üí ${sender._id}`);
    }

    res.status(200).json({ message: "L·ªùi m·ªùi k·∫øt b·∫°n ƒë√£ b·ªã t·ª´ ch·ªëi!" });
  } catch (error) {
    console.error("L·ªói khi t·ª´ ch·ªëi l·ªùi m·ªùi:", error);
    res.status(500).json({ message: "L·ªói server!" });
  }
};

// x√≥a b·∫°n
export const removeFriend = async (req, res) => {
  try {
    const { userId, friendId } = req.body;

    await User.findByIdAndUpdate(userId, { $pull: { friends: friendId } });
    await User.findByIdAndUpdate(friendId, { $pull: { friends: userId } });

    res.status(200).json({ message: "X√≥a b·∫°n b√® th√†nh c√¥ng!" });
  } catch (error) {
    console.error("L·ªói khi x√≥a b·∫°n b√®:", error);
    res.status(500).json({ message: "L·ªói server!" });
  }
};

// l·∫•y danh s√°ch b·∫°n b√®
export const getFriends = async (req, res) => {
  try {
    const { userId } = req.params;

    const user = await User.findById(userId).populate(
      "friends",
      "username email avatarUrl firstName lastName displayName status lastSeen"
    );
    if (!user) {
      return res.status(404).json({ message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i!" });
    }

    res.status(200).json({
      friends: user.friends,
      count: user.friends.length
    });
  } catch (error) {
    console.error("L·ªói khi l·∫•y danh s√°ch b·∫°n b√®:", error);
    res.status(500).json({ message: "L·ªói server!" });
  }
};

// üìå L·∫•y danh s√°ch l·ªùi m·ªùi k·∫øt b·∫°n ƒë√£ nh·∫≠n
export const getReceivedFriendRequests = async (req, res) => {
  try {
    const { userId } = req.params;

    const friendRequests = await FriendRequest.find({
      receiver: userId,
      status: "pending"
    }).populate('sender', 'username firstName lastName avatarUrl displayName')
      .sort({ createdAt: -1 });

    res.status(200).json({
      friendRequests,
      count: friendRequests.length
    });
  } catch (error) {
    console.error("L·ªói khi l·∫•y l·ªùi m·ªùi k·∫øt b·∫°n:", error);
    res.status(500).json({ message: "L·ªói server!" });
  }
};

// üìå L·∫•y danh s√°ch l·ªùi m·ªùi k·∫øt b·∫°n ƒë√£ g·ª≠i
export const getSentFriendRequests = async (req, res) => {
  try {
    const { userId } = req.params;

    const friendRequests = await FriendRequest.find({
      sender: userId,
      status: "pending"
    }).populate('receiver', 'username firstName lastName avatarUrl displayName')
      .sort({ createdAt: -1 });

    res.status(200).json({
      friendRequests,
      count: friendRequests.length
    });
  } catch (error) {
    console.error("L·ªói khi l·∫•y l·ªùi m·ªùi ƒë√£ g·ª≠i:", error);
    res.status(500).json({ message: "L·ªói server!" });
  }
};

// üìå L·∫•y danh s√°ch b·∫°n chung
export const getMutualFriends = async (req, res) => {
  try {
    const { user1, user2 } = req.params;

    // L·∫•y danh s√°ch b·∫°n b√® c·ªßa user1 & user2
    const user1Data = await User.findById(user1).populate(
      "friends",
      "_id username firstName lastName avatarUrl displayName"
    );
    const user2Data = await User.findById(user2).populate(
      "friends",
      "_id username firstName lastName avatarUrl displayName"
    );

    if (!user1Data || !user2Data) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng!" });
    }

    // T√¨m b·∫°n chung
    const user1Friends = new Set(
      user1Data.friends.map((friend) => friend._id.toString())
    );
    const mutualFriends = user2Data.friends.filter((friend) =>
      user1Friends.has(friend._id.toString())
    );

    res.status(200).json({
      mutualFriends,
      count: mutualFriends.length
    });
  } catch (error) {
    console.error("L·ªói khi l·∫•y b·∫°n chung:", error);
    res.status(500).json({ message: "L·ªói server!" });
  }
};

// üìå Ki·ªÉm tra tr·∫°ng th√°i k·∫øt b·∫°n
export const checkFriendship = async (req, res) => {
  try {
    const { user1, user2 } = req.params;

    const user = await User.findById(user1);
    if (!user) {
      return res.status(404).json({ message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i!" });
    }

    const isFriend = user.friends.includes(user2);

    // Ki·ªÉm tra l·ªùi m·ªùi k·∫øt b·∫°n pending
    const sentRequest = await FriendRequest.findOne({
      sender: user1,
      receiver: user2,
      status: "pending"
    });

    const receivedRequest = await FriendRequest.findOne({
      sender: user2,
      receiver: user1,
      status: "pending"
    });

    let status = "none"; // none, friends, sent, received
    
    if (isFriend) {
      status = "friends";
    } else if (sentRequest) {
      status = "sent";
    } else if (receivedRequest) {
      status = "received";
    }

    res.status(200).json({ 
      status,
      isFriend,
      requestId: sentRequest?._id || receivedRequest?._id
    });
  } catch (error) {
    console.error("L·ªói khi ki·ªÉm tra b·∫°n b√®:", error);
    res.status(500).json({ message: "L·ªói server!" });
  }
};

// üìå T√¨m ki·∫øm ng∆∞·ªùi d√πng ƒë·ªÉ k·∫øt b·∫°n
export const searchUsers = async (req, res) => {
  try {
    const { query, userId } = req.query;
    const currentUserId = userId;

    if (!query || query.trim().length < 2) {
      return res.status(400).json({ message: "T·ª´ kh√≥a t√¨m ki·∫øm qu√° ng·∫Øn!" });
    }

    const users = await User.find({
      $and: [
        { _id: { $ne: currentUserId } }, // Kh√¥ng bao g·ªìm ch√≠nh m√¨nh
        {
          $or: [
            { firstName: { $regex: query, $options: 'i' } },
            { lastName: { $regex: query, $options: 'i' } },
            { displayName: { $regex: query, $options: 'i' } },
            { username: { $regex: query, $options: 'i' } }
          ]
        }
      ]
    })
    .select('username firstName lastName displayName avatarUrl')
    .limit(20);

    // Ki·ªÉm tra tr·∫°ng th√°i k·∫øt b·∫°n cho t·ª´ng user
    const usersWithStatus = await Promise.all(
      users.map(async (user) => {
        const checkResult = await checkFriendshipStatus(currentUserId, user._id);
        return {
          ...user.toObject(),
          friendshipStatus: checkResult.status
        };
      })
    );

    res.status(200).json({
      users: usersWithStatus,
      count: usersWithStatus.length
    });
  } catch (error) {
    console.error("L·ªói khi t√¨m ki·∫øm ng∆∞·ªùi d√πng:", error);
    res.status(500).json({ message: "L·ªói server!" });
  }
};

// Helper function ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i k·∫øt b·∫°n
const checkFriendshipStatus = async (user1, user2) => {
  const user = await User.findById(user1);
  const isFriend = user.friends.includes(user2);
  
  const sentRequest = await FriendRequest.findOne({
    sender: user1,
    receiver: user2,
    status: "pending"
  });

  const receivedRequest = await FriendRequest.findOne({
    sender: user2,
    receiver: user1,
    status: "pending"
  });

  let status = "none";
  
  if (isFriend) {
    status = "friends";
  } else if (sentRequest) {
    status = "sent";
  } else if (receivedRequest) {
    status = "received";
  }

  return { status, requestId: sentRequest?._id || receivedRequest?._id };
};
